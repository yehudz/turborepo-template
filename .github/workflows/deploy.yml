name: Deploy Application

on:
  workflow_dispatch: # Manual deployment only
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - prod
      confirm_deployment:
        description: 'Type "DEPLOY" to confirm'
        required: true
        type: string

# Prevent concurrent deployments per environment
concurrency:
  group: deploy-${{ inputs.environment }}
  cancel-in-progress: false

jobs:
  validate-deployment:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ inputs.confirm_deployment }}" != "DEPLOY" ]; then
            echo "‚ùå Deployment cancelled: confirmation must be exactly 'DEPLOY'"
            echo "You entered: '${{ inputs.confirm_deployment }}'"
            exit 1
          fi
          echo "‚úÖ Deployment confirmation validated"
          
      - name: Show deployment info
        run: |
          echo "üöÄ Deploying to: ${{ inputs.environment }}"
          echo "üì¶ Commit: ${{ github.sha }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üåø Branch: ${{ github.ref_name }}"

  build-and-deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: validate-deployment
    environment: ${{ inputs.environment }}

    # Required permissions for workload identity
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Detect changed apps
        run: |
          echo "Detecting which apps have changes since last commit..."
          
          # Get list of changed packages/apps
          CHANGED_APPS=$(pnpm turbo run build --filter=...[HEAD^1] --dry-run=json | jq -r '.tasks[] | select(.task == "build") | .package' | grep -E "^(web|admin)$" || true)
          
          if [ -z "$CHANGED_APPS" ]; then
            echo "No app changes detected. Building all apps for safety."
            echo "DEPLOY_WEB=true" >> $GITHUB_ENV
            echo "DEPLOY_ADMIN=true" >> $GITHUB_ENV
          else
            echo "Changed apps detected: $CHANGED_APPS"
            if echo "$CHANGED_APPS" | grep -q "web"; then
              echo "DEPLOY_WEB=true" >> $GITHUB_ENV
              echo "üì¶ Web app has changes - will deploy"
            else
              echo "DEPLOY_WEB=false" >> $GITHUB_ENV
              echo "‚è≠Ô∏è  Web app unchanged - skipping"
            fi
            
            if echo "$CHANGED_APPS" | grep -q "admin"; then
              echo "DEPLOY_ADMIN=true" >> $GITHUB_ENV
              echo "üì¶ Admin app has changes - will deploy"
            else
              echo "DEPLOY_ADMIN=false" >> $GITHUB_ENV
              echo "‚è≠Ô∏è  Admin app unchanged - skipping"
            fi
          fi

      - name: Build packages
        run: pnpm build

      - name: Build changed apps
        run: |
          if [ "${{ env.DEPLOY_WEB }}" = "true" ]; then
            echo "Building web app..."
            pnpm --filter web build
          fi
          
          if [ "${{ env.DEPLOY_ADMIN }}" = "true" ]; then
            echo "Building admin app..."
            pnpm --filter admin build
          fi

      # Authenticate to Google Cloud using Workload Identity
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ vars.REGION }}-docker.pkg.dev

      - name: Create Dockerfile for web app
        if: env.DEPLOY_WEB == 'true'
        run: |
          cat > apps/web/Dockerfile << 'EOF'
          FROM node:18-alpine AS base
          
          # Builder stage - install dependencies and build
          FROM base AS builder
          RUN apk add --no-cache libc6-compat
          WORKDIR /app
          
          # Install pnpm
          RUN npm install -g pnpm
          
          # Copy all files for build
          COPY . .
          
          # Install ALL dependencies (including dev deps needed for build)
          RUN pnpm install --frozen-lockfile --ignore-scripts
          
          # Build packages and web app
          RUN pnpm build
          RUN pnpm --filter web build
          
          # Production image
          FROM base AS runner
          WORKDIR /app
          
          ENV NODE_ENV=production
          ENV PORT=3000
          ENV HOSTNAME="0.0.0.0"
          
          RUN addgroup --system --gid 1001 nodejs
          RUN adduser --system --uid 1001 nextjs
          
          # Copy built application files
          COPY --from=builder --chown=nextjs:nodejs /app/apps/web/.next/standalone ./
          COPY --from=builder --chown=nextjs:nodejs /app/apps/web/.next/static ./apps/web/.next/static
          
          # Create public directory
          RUN mkdir -p ./public && chown nextjs:nodejs ./public
          
          USER nextjs
          
          EXPOSE 3000
          
          CMD ["node", "apps/web/server.js"]
          EOF

      - name: Create Dockerfile for admin app
        if: env.DEPLOY_ADMIN == 'true'
        run: |
          cat > apps/admin/Dockerfile << 'EOF'
          FROM node:18-alpine AS base
          
          # Builder stage - install dependencies and build
          FROM base AS builder
          RUN apk add --no-cache libc6-compat
          WORKDIR /app
          
          # Install pnpm
          RUN npm install -g pnpm
          
          # Copy all files for build
          COPY . .
          
          # Install ALL dependencies (including dev deps needed for build)
          RUN pnpm install --frozen-lockfile --ignore-scripts
          
          # Build packages and admin app
          RUN pnpm build
          RUN pnpm --filter admin build
          
          # Production image
          FROM base AS runner
          WORKDIR /app
          
          ENV NODE_ENV=production
          ENV PORT=3000
          ENV HOSTNAME="0.0.0.0"
          
          RUN addgroup --system --gid 1001 nodejs
          RUN adduser --system --uid 1001 nextjs
          
          # Copy built application files
          COPY --from=builder --chown=nextjs:nodejs /app/apps/admin/.next/standalone ./
          COPY --from=builder --chown=nextjs:nodejs /app/apps/admin/.next/static ./apps/admin/.next/static
          
          # Create public directory
          RUN mkdir -p ./public && chown nextjs:nodejs ./public
          
          USER nextjs
          
          EXPOSE 3000
          
          CMD ["node", "apps/admin/server.js"]
          EOF

      - name: Build and push Docker images
        run: |
          # Build and push web app (if changed)
          if [ "${{ env.DEPLOY_WEB }}" = "true" ]; then
            echo "Building and pushing web app Docker image..."
            WEB_IMAGE_URL="${{ vars.REGION }}-docker.pkg.dev/${{ vars.PROJECT_ID }}/${{ vars.ARTIFACT_REGISTRY_REPO }}/web:${{ github.sha }}"
            docker build -t $WEB_IMAGE_URL -f apps/web/Dockerfile .
            docker push $WEB_IMAGE_URL
            echo "WEB_IMAGE_URL=$WEB_IMAGE_URL" >> $GITHUB_ENV
          else
            echo "‚è≠Ô∏è  Skipping web app Docker build - no changes"
          fi
          
          # Build and push admin app (if changed)
          if [ "${{ env.DEPLOY_ADMIN }}" = "true" ]; then
            echo "Building and pushing admin app Docker image..."
            ADMIN_IMAGE_URL="${{ vars.REGION }}-docker.pkg.dev/${{ vars.PROJECT_ID }}/${{ vars.ARTIFACT_REGISTRY_REPO }}/admin:${{ github.sha }}"
            docker build -t $ADMIN_IMAGE_URL -f apps/admin/Dockerfile .
            docker push $ADMIN_IMAGE_URL
            echo "ADMIN_IMAGE_URL=$ADMIN_IMAGE_URL" >> $GITHUB_ENV
          else
            echo "‚è≠Ô∏è  Skipping admin app Docker build - no changes"
          fi

      - name: Set environment-specific config
        run: |
          # Set resource limits based on environment
          if [ "${{ inputs.environment }}" = "prod" ]; then
            echo "MIN_INSTANCES=1" >> $GITHUB_ENV
            echo "MAX_INSTANCES=100" >> $GITHUB_ENV
            echo "MEMORY=2Gi" >> $GITHUB_ENV
            echo "CPU=2" >> $GITHUB_ENV
            echo "WEB_SERVICE_NAME=web-app" >> $GITHUB_ENV
            echo "ADMIN_SERVICE_NAME=admin-app" >> $GITHUB_ENV
          else
            echo "MIN_INSTANCES=0" >> $GITHUB_ENV
            echo "MAX_INSTANCES=10" >> $GITHUB_ENV
            echo "MEMORY=512Mi" >> $GITHUB_ENV
            echo "CPU=1" >> $GITHUB_ENV
            echo "WEB_SERVICE_NAME=web-app-dev" >> $GITHUB_ENV
            echo "ADMIN_SERVICE_NAME=admin-app-dev" >> $GITHUB_ENV
          fi
          
      - name: Deploy web app to Cloud Run
        if: env.DEPLOY_WEB == 'true'
        run: |
          gcloud run deploy ${{ env.WEB_SERVICE_NAME }} \
            --image ${{ env.WEB_IMAGE_URL }} \
            --region ${{ vars.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 3000 \
            --memory ${{ env.MEMORY }} \
            --cpu ${{ env.CPU }} \
            --min-instances ${{ env.MIN_INSTANCES }} \
            --max-instances ${{ env.MAX_INSTANCES }} \
            --set-env-vars NODE_ENV=${{ inputs.environment }} \
            --set-env-vars ENVIRONMENT=${{ inputs.environment }} \
            --set-secrets DATABASE_URL=DATABASE_URL:latest \
            --set-secrets NEXT_PUBLIC_APPWRITE_PROJECT_ID=NEXT_PUBLIC_APPWRITE_PROJECT_ID:latest \
            --set-secrets NEXT_PUBLIC_APPWRITE_URL=NEXT_PUBLIC_APPWRITE_URL:latest \
            --set-secrets GOOGLE_CLOUD_BUCKET_NAME=GOOGLE_CLOUD_BUCKET_NAME:latest

      - name: Deploy admin app to Cloud Run
        if: env.DEPLOY_ADMIN == 'true'
        run: |
          gcloud run deploy ${{ env.ADMIN_SERVICE_NAME }} \
            --image ${{ env.ADMIN_IMAGE_URL }} \
            --region ${{ vars.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 3000 \
            --memory ${{ env.MEMORY }} \
            --cpu ${{ env.CPU }} \
            --min-instances ${{ env.MIN_INSTANCES }} \
            --max-instances ${{ env.MAX_INSTANCES }} \
            --set-env-vars NODE_ENV=${{ inputs.environment }} \
            --set-env-vars ENVIRONMENT=${{ inputs.environment }} \
            --set-secrets DATABASE_URL=DATABASE_URL:latest \
            --set-secrets NEXT_PUBLIC_APPWRITE_PROJECT_ID=NEXT_PUBLIC_APPWRITE_PROJECT_ID:latest \
            --set-secrets NEXT_PUBLIC_APPWRITE_URL=NEXT_PUBLIC_APPWRITE_URL:latest \
            --set-secrets GOOGLE_CLOUD_BUCKET_NAME=GOOGLE_CLOUD_BUCKET_NAME:latest

      - name: Get service URLs
        run: |
          echo "üöÄ Successfully deployed to ${{ inputs.environment }}"
          
          if [ "${{ env.DEPLOY_WEB }}" = "true" ]; then
            WEB_SERVICE_URL=$(gcloud run services describe ${{ env.WEB_SERVICE_NAME }} --region ${{ vars.REGION }} --format 'value(status.url)')
            echo "üìç Web App URL: $WEB_SERVICE_URL"
            echo "üè∑Ô∏è  Web Service: ${{ env.WEB_SERVICE_NAME }}"
            echo "üíæ Web Image: ${{ env.WEB_IMAGE_URL }}"
            echo "WEB_SERVICE_URL=$WEB_SERVICE_URL" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  Web app skipped - no changes"
          fi
          
          if [ "${{ env.DEPLOY_ADMIN }}" = "true" ]; then
            ADMIN_SERVICE_URL=$(gcloud run services describe ${{ env.ADMIN_SERVICE_NAME }} --region ${{ vars.REGION }} --format 'value(status.url)')
            echo "üìç Admin App URL: $ADMIN_SERVICE_URL"
            echo "üè∑Ô∏è  Admin Service: ${{ env.ADMIN_SERVICE_NAME }}"
            echo "üíæ Admin Image: ${{ env.ADMIN_IMAGE_URL }}"
            echo "ADMIN_SERVICE_URL=$ADMIN_SERVICE_URL" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  Admin app skipped - no changes"
          fi